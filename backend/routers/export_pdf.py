"""Router for PDF export — converts a markdown report to PDF."""

import io
import json
import logging
from datetime import datetime, timezone
from typing import Any, Dict, Optional, Union

from fastapi import APIRouter, HTTPException, Request
from fastapi.responses import StreamingResponse
from pydantic import BaseModel

from backend.rate_limit import limiter, EXPENSIVE_LIMIT

log = logging.getLogger(__name__)

router = APIRouter(tags=["export"])


class PdfExportRequest(BaseModel):
    """Request body for /export-pdf."""

    markdown_text: Optional[str] = None
    evaluation_json: Optional[dict] = None
    repo_name: Optional[str] = None


# ---------------------------------------------------------------------------
# Markdown → HTML → PDF pipeline
# ---------------------------------------------------------------------------

_CSS = """
@page {
    size: A4;
    margin: 2cm;
}
body {
    font-family: Helvetica, Arial, sans-serif;
    font-size: 11px;
    line-height: 1.6;
    color: #1a1a2e;
}
h1 { font-size: 22px; margin-top: 0; color: #1e293b; border-bottom: 2px solid #2563eb; padding-bottom: 6px; }
h2 { font-size: 17px; color: #334155; margin-top: 20px; }
h3 { font-size: 14px; color: #475569; margin-top: 16px; }
p  { margin-bottom: 8px; }
ul, ol { margin-bottom: 8px; padding-left: 20px; }
li { margin-bottom: 4px; }
code {
    background: #f1f5f9;
    padding: 1px 4px;
    border-radius: 3px;
    font-family: Courier, monospace;
    font-size: 10px;
}
pre {
    background: #f1f5f9;
    padding: 10px;
    border-radius: 4px;
    font-size: 10px;
    white-space: pre-wrap;
    word-break: break-word;
}
table { border-collapse: collapse; width: 100%; margin-bottom: 12px; }
th, td { border: 1px solid #cbd5e1; padding: 6px 10px; font-size: 10px; text-align: left; }
th { background: #f1f5f9; font-weight: bold; }
blockquote { border-left: 3px solid #2563eb; padding-left: 12px; color: #64748b; margin: 8px 0; }
strong { font-weight: bold; }
.footer { text-align: center; font-size: 9px; color: #94a3b8; margin-top: 30px; border-top: 1px solid #e2e8f0; padding-top: 8px; }
"""


def _markdown_to_html(md_text: str, repo_name: Optional[str]) -> str:
    """Convert markdown text to a full HTML document for PDF rendering."""
    import markdown

    extensions = [
        "markdown.extensions.tables",
        "markdown.extensions.fenced_code",
        "markdown.extensions.codehilite",
        "markdown.extensions.toc",
        "markdown.extensions.nl2br",
    ]
    html_body = markdown.markdown(md_text, extensions=extensions)

    title = f"README Evaluation — {repo_name}" if repo_name else "README Evaluation Report"
    now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

    return f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>{title}</title>
    <style>{_CSS}</style>
</head>
<body>
    <h1>{title}</h1>
    {html_body}
    <div class="footer">
        Generated by README Evaluator on {now}
    </div>
</body>
</html>"""


def _json_to_markdown(evaluation: dict) -> str:
    """Build a minimal markdown report from raw evaluation JSON."""
    lines: list[str] = []
    meta = evaluation.get("metadata", {})
    lines.append(f"# Evaluation: {meta.get('repository_name', 'Unknown')}")
    lines.append("")
    if meta.get("evaluation_date"):
        lines.append(f"**Date:** {meta['evaluation_date']}  ")
    if meta.get("evaluator"):
        lines.append(f"**Model:** {meta['evaluator']}  ")
    lines.append("")

    categories = evaluation.get("categories", {})
    for cat_name, cat_data in categories.items():
        score = cat_data.get("score", "N/A")
        lines.append(f"## {cat_name.replace('_', ' ').title()} — Score: {score}/5")
        lines.append("")

        justifications = cat_data.get("justifications", [])
        if isinstance(justifications, list):
            for j in justifications:
                lines.append(f"- {j}")
        elif isinstance(justifications, str):
            lines.append(f"- {justifications}")
        lines.append("")

    return "\n".join(lines)


def _html_to_pdf(html: str) -> bytes:
    """Convert HTML string to PDF bytes using xhtml2pdf."""
    from xhtml2pdf import pisa

    buf = io.BytesIO()
    pisa_status = pisa.CreatePDF(io.StringIO(html), dest=buf)
    if pisa_status.err:
        raise RuntimeError(f"xhtml2pdf conversion errors: {pisa_status.err}")
    return buf.getvalue()


# ---------------------------------------------------------------------------
# Endpoint
# ---------------------------------------------------------------------------

@router.post("/export-pdf")
@limiter.limit(EXPENSIVE_LIMIT)
def export_pdf(request: Request, req: PdfExportRequest):
    """Generate a PDF from a markdown report or raw evaluation JSON.

    Priority:
      1. ``markdown_text`` — convert directly
      2. ``evaluation_json`` — build markdown first, then convert
    """
    try:
        md_text: Optional[str] = req.markdown_text
        if not md_text and req.evaluation_json:
            md_text = _json_to_markdown(req.evaluation_json)
        if not md_text:
            raise ValueError(
                "Provide either markdown_text or evaluation_json to generate a PDF."
            )

        html = _markdown_to_html(md_text, req.repo_name)
        pdf_bytes = _html_to_pdf(html)

        filename = f"readme-evaluation-{req.repo_name or 'report'}.pdf".replace("/", "-")

        return StreamingResponse(
            io.BytesIO(pdf_bytes),
            media_type="application/pdf",
            headers={"Content-Disposition": f'attachment; filename="{filename}"'},
        )
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc))
    except Exception as exc:
        log.exception("PDF export failed")
        raise HTTPException(status_code=500, detail=f"PDF generation failed: {exc}")
